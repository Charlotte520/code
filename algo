1. 求正整数的二进制表示包含多少个1
位移法：向右位移32次，每次与1 &，得到1则加一。
求与法：x与x-1的二进制表示，最后一个1变成0,其后的0变成1,高位不变。x=x&(x-1)，直到x为0。  判断一个int是否为2的x次幂：二进制表示只有1个1
查表法：空间换时间。表中记录2^32个int32的结果，每个int32最多有32个1,用5bit表示，共2.5GB。=》把int32分成低16位和高16位，x&(0xffff),(x>>16)&(0xffff)，分别查表再求和。表中记录2^16个结果，每个用4bit，共32KB。

2.求斐波那契数列f(n)
递归：指数时间。
正向：o(n)。
通项公式：f(n)=(1/√5)*{[(1+√5)/2]^n -[(1-√5)/2]^n}。=》求a^n：若n为偶数，求r=a^(n/2)，再r*r。若n为奇数，求r=a^((n-1)/2)，再r*r*a。o(logn)。
查表。

3. topk
排序：o(nlogn)  不需全局排序
局部排序：o(n*k)
堆：不对topk排序。o(nlogk)
随机选择：i=partition(arr,1,n)。若i>k，递归a[1,i-1]求第k大。若i<k，递归a[i+1,n]求k-i大。

4.o(n)排序 
基数排序radix sort：对每个基，遍历arr，放入bucket，再遍历bucket，将元素放回arr。稳定
计数排序counting sort：元素个数多，范围小。C[max-min]
桶排序bucket sort：元素在某范围内均匀分布。空间：桶+桶内链表。遍历将元素入桶，桶内插入排序。稳定

